В декларативном синтаксисе объявляются вложенные конструкции - получается матрёшка. На верхнем уровне - пайплайн (Pipeline), который состоит из этапов (Stages) . Этапы состоят из  шагов (Steps), шагами могут быть как отдельные операторы, вызовы функций, так и скрипты (Script) или нестандартные конструкции-обертки для кода, предоставляемые различными плагинами.

=============================================================

pipeline {
    agent any
    stages {
        stage( ' Example ' ) {
            steps {
                echo ' Hello World '   // Это отдельный вызов функции

                script {               // Это скрипт
                    def  browsers = [ ' chrome ' , ' firefox ' ]
                    for  ( int  i = 0 ; i < browsers.size(); ++i) {
                        echo " Testing the ${ browsers[i] }  browser "
                    }
                }
            }
        }
    }
}

==========================================================================

В декларативном пайплайне также легко можно задавать условия выполнения этапа сборки, что даёт возможность включать/отключать этапы выполнения не прибегая к громоздким условным операторам внутри блока steps. Например:

       stage('Load test extension') {
           // Это условие выполнения этапа. Если параметр задачи load_test_extention будет
           // равен false, то Jenkins не будет выполнять этот этап и сразу перейдет к следующему

            when { expression { params.load_test_extension } }  
            steps { script {

                def statusCode = commonMethods.cmdReturnStatusCode([
                    baseDesignerCommandWithAuth,
                    "/LoadCfg \"./test_extension.cfe\" -Extension ${env.TEST_EXTENSION_NAME}"
                ])

=======================================================                

Некоторые "декларативные" опции доступны не только для этапов, но и для пайплайна в целом. Например можно всего в одном месте указать timestamps():

 pipeline {

    options { timestamps() }

    stages {

        stage('Init environment') {

            steps { script {

 
и тогда к выводу каждой команды в логах будет автоматически добавляться время её выполнения.

=========================================================================

Блок pipeline описывает правила выполнения всей задачи в целом. По сути дела он и представляет собой задачу, за исключением настроек, хранящихся в xml-файле задачи и редактируемых как правило не через код, а через web-интерфейс Jenkins.

На уровне блока pipeline можно определять ряд общих свойств.

Метки, которыми должен обладать сборочный узел, чтобы на него была назначена эта задача. 
Время хранения данных о прошедших сборках.
Количество сборок, данные о которых нужно хранить.
Необходимость выводить момент времени для каждого оператора в логах.
и так далее.

===============================================================================

Этапы - stages - это вехи пайплайна. Крупные логические блоки. Все элементы stage объединены в общий блок stages. Подозреваю что это сделано для упрощения парсинга текста Jenkinsfile, так как это не сильно упрощает чтение текста модуля и приводит к добавлению лишнего отступа в коде. 

С точки зрения логической организации удобно разделять весь процесс сборки (пайплан) на эти блоки (этапы), чтобы можно было проще ими управлять и проще осуществлять поддержку ранее написанного кода. Например если в процессе сборки и тестирования выполняется загрузка конфигурации 1С, затем сценарное тестирование, затем дымовое тестирование, затем удаление протестированного cf-файла или его перенос в какое-то хранилище, то правильно будет разбить эти действия на отдельные этапы.

При этом в дополнение к логической организации кода мы получим удобное визуальное представление этапов выполнения с данными о затратах времени на каждый из этапов. И в случае ошибки сборки всегда будет ясно, на каком именно этапе она произошла.
=======================================================================

Шаги - steps - в отличие от этапов элементы "подневольные". Они всегда выполняются в рамках своего этапа, и по умолчанию всегда последовательно. Каждый шаг - это отдельный оператор или вызов функции.

Для того чтобы организовать из шагов настоящий алгоритм, нужно включить их в специальный блок script. В этом случае можно будет помещать шаги в условные операторы и циклы.

Отдельные выполненные операторы также имеют не только текстовое представление в логах, но и визуальное представление. Если кликнуть мышкой по отдельному блоку (квадрату) с этапом сборки, то можно вызвать просмотр логов выполнения в графическом виде.

===========================================================================

Переменные и операторы
 

Groovy  позволяет объявлять как общие для всего скрипта переменные, так и переменные внутри отдельных блоков.

При этом переменные, объявленные для всего скрипта хранятся на мастер узле Jenkins на сервере. А переменные, объявленные внутри отдельных блоков создаются и хранятся на стороне подчиненных узлов. Дело в том, что отдельные этапы сборки (элементы блока Stages) могут выполняться на разных компьютерах, на разных подчиненных узлах, если их об этом "попросить" (указывать узел-компьютер на котором требуется выполнить этап сборки можно на уровне самого этапа). При этом переменные, объявленные для всего скрипта, должны быть доступны на всех машинах.

Здесь, как и в случае платформы 1С, вмешивается клиент-серверное взаимодействие. Переменные объявленные для всего скрипта должны относиться либо к примитивным типам, либо представлять собой Java-объекты, поддерживающие сериализацию/десериализацию, что необходимо для их передачи между разными машинами. В нашем случае в этих переменных будут храниться главным образом объекты класса String - строки. Поэтому проблем с сериализацией возникать не будет.

 

 

 def baseDesignerCommand

 def baseEnterpriseCommand

 def baseDesignerCommandWithAuth

 def baseEnterpriseCommandWithAuth

 def baseEnterpriseCommandWithAuthRu

 def timeoutBeforeDeleteTestDatabase

 

 

 pipeline {

 

     agent { label 'ubuntu_interactive' }

   

     stages {

        stage('Compiling EPF for initialization') {

 

             steps { script {

                     def statusCode = commonMethods.cmdReturnStatusCode("текст команды")

                     commonMethods.cmdReturnStatusCode("tail -n 5 ${outFileName}")

 

                     def outputLine = commonMethods.getLastLineOfTextFileLowerCase(outFileName)

                     def success = (statusCode == 0) && outputLine.contains("import completed")

                     commonMethods.assertWithEcho(success, "EPF was not compiled", "EPF was successfully compiled")

             }}

         }

 

 

Объявляя переменную на уровне всего скрипта за пределами блока pipeline (в начале файла) обязательно использовать ключевое слово def . После этого она становится доступна для использования во всех блоках скрипта.  Для переменных, создаваемых внутри отдельных блоков необходимости в этом нет. Переменная будет создана автоматически, когда ей впервые присваивается значение. Но здесь важно понимать, что если внутри блока первое обращение к переменной происходит без ключевого слова def, то создается "глобальная" переменная, которая будет доступна и из всех следующих блоков.

На практике возможность объявлять глобальные переменные в отдельных блоках очень неудобна и только ведёт к путанице. Поэтому лучше взять за правило выносить объявление таких переменных за блок pipeline в начало файла (как в примере кода выше) . Это простое правило позволит сэкономить много времени на поиске ошибок и отладке, которая в Jenkins является непростой задачей.

===========================================================================

